stages:
  - test
  - build
  - package
  - publish

test:
  stage: test
  image: python:3.11-slim
  script:
    - pip install .[dev]
    - pytest
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

build:
  stage: build
  image: python:3.11-slim
  script:
    - pip install build
    - python -m build
  artifacts:
    paths:
      - dist/
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/

build-packages:
  stage: package
  image: python:3.11-slim
  before_script:
    - apt-get update && apt-get install -y curl
    - |
      NFPM_VERSION=$(curl -s https://api.github.com/repos/goreleaser/nfpm/releases/latest | python3 -c "import sys,json; print(json.load(sys.stdin)['tag_name'])")
      echo "Installing nfpm ${NFPM_VERSION}..."
      curl -fL -o /tmp/nfpm.tar.gz "https://github.com/goreleaser/nfpm/releases/download/${NFPM_VERSION}/nfpm_${NFPM_VERSION#v}_Linux_x86_64.tar.gz"
      tar -xzf /tmp/nfpm.tar.gz -C /usr/local/bin nfpm
      nfpm --version
    - pip install build
  script:
    - bash packaging/build-packages.sh
  artifacts:
    paths:
      - dist/*.deb
      - dist/*.rpm
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
  needs:
    - build

publish-testpypi:
  stage: publish
  image: python:3.11-slim
  script:
    - pip install twine
    - twine upload --repository-url https://test.pypi.org/legacy/ dist/*.whl dist/*.tar.gz
  variables:
    TWINE_USERNAME: __token__
    TWINE_PASSWORD: $TESTPYPI_TOKEN
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
  needs:
    - build
  allow_failure: true

publish-pypi:
  stage: publish
  image: python:3.11-slim
  script:
    - pip install twine
    - twine upload dist/*.whl dist/*.tar.gz
  variables:
    TWINE_USERNAME: __token__
    TWINE_PASSWORD: $PYPI_TOKEN
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
      when: manual
  needs:
    - build

publish-packages:
  stage: publish
  image: curlimages/curl:latest
  script:
    - |
      for f in dist/*.deb dist/*.rpm; do
        [ -f "$f" ] || continue
        echo "Uploading $(basename "$f")..."
        curl -k --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
             --upload-file "$f" \
             "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/zpbs-backup/${CI_COMMIT_TAG}/$(basename "$f")"
      done
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
  needs:
    - build-packages

create-release:
  stage: publish
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - VERSION="${CI_COMMIT_TAG#v}"
    - PKG_URL="${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/zpbs-backup/${CI_COMMIT_TAG}"
    - |
      release-cli create \
        --name "zpbs-backup ${CI_COMMIT_TAG}" \
        --tag-name "${CI_COMMIT_TAG}" \
        --description "Release ${CI_COMMIT_TAG}" \
        --assets-link "{\"name\":\"zpbs-backup_${VERSION}_amd64.deb\",\"url\":\"${PKG_URL}/zpbs-backup_${VERSION}_amd64.deb\",\"link_type\":\"package\"}" \
        --assets-link "{\"name\":\"zpbs-backup_${VERSION}_arm64.deb\",\"url\":\"${PKG_URL}/zpbs-backup_${VERSION}_arm64.deb\",\"link_type\":\"package\"}" \
        --assets-link "{\"name\":\"zpbs-backup-${VERSION}.x86_64.rpm\",\"url\":\"${PKG_URL}/zpbs-backup-${VERSION}.x86_64.rpm\",\"link_type\":\"package\"}" \
        --assets-link "{\"name\":\"zpbs-backup-${VERSION}.aarch64.rpm\",\"url\":\"${PKG_URL}/zpbs-backup-${VERSION}.aarch64.rpm\",\"link_type\":\"package\"}"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
  needs:
    - publish-packages

publish-github:
  stage: publish
  image: alpine:latest
  variables:
    GITHUB_REPO: "ndemarco/zpbs-backup"
  before_script:
    - apk add --no-cache curl jq
  script:
    - VERSION="${CI_COMMIT_TAG#v}"
    # Wait for the mirror to push the tag to GitHub (up to 2 minutes)
    - |
      echo "Waiting for tag ${CI_COMMIT_TAG} to appear on GitHub..."
      for i in $(seq 1 12); do
        STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          "https://api.github.com/repos/${GITHUB_REPO}/git/refs/tags/${CI_COMMIT_TAG}")
        [ "$STATUS" = "200" ] && break
        echo "  Attempt $i/12 - tag not yet mirrored (HTTP $STATUS), waiting 10s..."
        sleep 10
      done
      if [ "$STATUS" != "200" ]; then
        echo "ERROR: Tag ${CI_COMMIT_TAG} not found on GitHub after 2 minutes"
        exit 1
      fi
    # Create GitHub release
    - |
      echo "Creating GitHub release..."
      RELEASE_RESPONSE=$(curl -s -X POST \
        -H "Authorization: token ${GITHUB_TOKEN}" \
        -H "Content-Type: application/json" \
        "https://api.github.com/repos/${GITHUB_REPO}/releases" \
        -d "{\"tag_name\":\"${CI_COMMIT_TAG}\",\"name\":\"zpbs-backup ${CI_COMMIT_TAG}\",\"body\":\"Release ${CI_COMMIT_TAG}\\n\\nSee [CHANGELOG.md](https://github.com/${GITHUB_REPO}/blob/main/CHANGELOG.md) for details.\",\"draft\":false,\"prerelease\":false}")
      UPLOAD_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.upload_url' | sed 's/{?name,label}//')
      RELEASE_URL=$(echo "$RELEASE_RESPONSE" | jq -r '.html_url')
      if [ "$UPLOAD_URL" = "null" ] || [ -z "$UPLOAD_URL" ]; then
        echo "ERROR: Failed to create release"
        echo "$RELEASE_RESPONSE" | jq .
        exit 1
      fi
      echo "Release created: $RELEASE_URL"
    # Upload all .deb and .rpm assets
    - |
      for f in dist/*.deb dist/*.rpm; do
        [ -f "$f" ] || continue
        FILENAME=$(basename "$f")
        echo "Uploading ${FILENAME}..."
        if echo "$FILENAME" | grep -q '\.deb$'; then
          CONTENT_TYPE="application/vnd.debian.binary-package"
        else
          CONTENT_TYPE="application/x-rpm"
        fi
        curl -s -X POST \
          -H "Authorization: token ${GITHUB_TOKEN}" \
          -H "Content-Type: ${CONTENT_TYPE}" \
          --data-binary "@$f" \
          "${UPLOAD_URL}?name=${FILENAME}" | jq -r '"  -> " + .name + " (" + .state + ")"'
      done
    - echo "GitHub release published at ${RELEASE_URL}"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v/
  needs:
    - build
    - build-packages
